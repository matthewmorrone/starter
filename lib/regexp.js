
function Match(match) {this.index = match.index; this.match = []; for (var i = 0, var len = match.length; i < len; i++) {this.match.push(match[i]); } };
Match.prototype.captures = function() {return this.match.slice(1); };
Match.prototype.toString = function() {return this.match[0]; };
RegExp.escape = function(s) {return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); };
RegExp.isRegExp = function(obj) {return ((obj != null ? obj.is_regexp : void 0) != null) || nativeToString.call(obj) === '[object RegExp]'; };
RegExp.union = function() {var arg, args, first_arg, sources; args = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : []; if (args.length === 0) {return new RegExp(/(?!)/); } first_arg = R(args[0]); if ((first_arg.is_array != null) && args.length === 1) {args = first_arg; } sources = (function() {var _k, _len2, _results; _results = []; for (_k = 0, _len2 = args.length; _k < _len2; _k++) {arg = args[_k]; arg = R(arg); if (arg.is_regexp != null) {_results.push(arg); } else {_results.push(arg); } } return _results; })(); return new RegExp(sources.join('|')); };
RegExp.prototype.construct = function(exp) {this.exp = exp; };
RegExp.prototype.escape = function() {pattern = String(this); return pattern.replace(/([.?*+^$[\](){}|-])/g, "\\$1").replace(/[\f]/g, '\\f').replace(/[\n]/g, '\\n').replace(/[\r]/g, '\\r').replace(/[\t]/g, '\\t').replace(/[\s]/g, '\\ '); };
RegExp.prototype.EXTENDED = 2;
RegExp.prototype.grep = function(input, flags) {var pattern = this; var p = ''; var retObj = {}; var invert = (flags === 1 || flags === 'PREG_GREP_INVERT'); if (typeof pattern === 'string') {pattern = eval(pattern); } if (invert) {for (p in input) {if ((input[p] + '').search(pattern) === -1) {retObj[p] = input[p]; } } } else {for (p in input) {if ((input[p] + '').search(pattern) !== -1) {retObj[p] = input[p]; } } } return retObj; }
RegExp.prototype.IGNORECASE = 1;
RegExp.prototype.is_regexp = function() {return true; };
RegExp.prototype.match = function() {var str = this; if (str === undefined) throw new Error('No string given'); if (!this.exp.global) {return this.exp.exec(str); } else {var matches = []; var match; this.exp.compile(this.exp); while ((match = this.exp.exec(str)) !== null) {matches.push(new Match(match)); } return matches; } };
RegExp.prototype.match = function(subject, matches, flags, offset) {var pattern = this; var i = 0, lastDelimPos = -1, flag = '', patternPart = '', flagPart = '', array = [], regexpFlags = '', subPatternNames = []; var getFuncName = function(fn) {var name = (/\W*function\s+([\w\$]+)\s*\(/).exec(fn); if (!name) {return '(Anonymous)'; } return name[1]; }; var join = function(arr) {return '(?:' + arr.join('|') + ')'; }; if (typeof pattern === 'string') {if (pattern === '') {} lastDelimPos = pattern.lastIndexOf(pattern[0]); if (lastDelimPos === 0) {pattern = new RegExp(pattern); } else {patternPart = pattern.slice(1, lastDelimPos); flagPart = pattern.slice(lastDelimPos + 1); for (i = 0; i < flagPart.length; i++) {flag = flagPart[i]; switch (flag) {case 'g': case 'm': case 'i': regexpFlags += flag; break; case 'e': break; case 's': case 'x': case 'A': case 'D': case 'U': case 'J': case 'u': throw 'The passed flag "' + flag + '" is presently unsupported in ' + getFuncName(arguments.callee); case 'X': throw 'X flag is unimplemented at present'; if (/\/([^\\^$.[\]|()?*+{}aefnrtdDhHsSvVwWbBAZzGCcxkgpPX\d])/.test(patternPart)) {throw 'You are in "X" (PCRE_EXTRA) mode, using a reserved and presently unused escape sequence in ' + getFuncName(arguments.callee); } break; case 'S': throw 'The passed flag "' + flag + '" to ' + getFuncName(arguments.callee) + ' cannot be implemented in JavaScript'; case 'y': throw 'Flag "y" is a non-cross-browser, non-PHP flag, not supported in ' + getFuncName(arguments.callee); default: throw 'Unrecognized flag "' + flag + '" passed to ' + getFuncName(arguments.callee); } } } } else {patternPart = pattern.source; regexpFlags += pattern.global ? 'g' : ''; regexpFlags += pattern.ignoreCase ? 'i' : ''; regexpFlags += pattern.multiline ? 'm' : ''; } patternPart = patternPart.replace(/\(\?<(.*?)>(.*?)\)/g, function(namedSubpattern, name, pattern) {subPatternNames.push(name); return '(' + pattern + ')'; }); pattern = new RegExp(patternPart, regexpFlags); array[0] = pattern.exec(subject); if (!array[0]) {return 0; } if (offset) {} if (flags === 'PREG_OFFSET_CAPTURE' || flags === 256) {return 1; } for (i = 0; i < array[0].length; i++) {matches[i] = array[0][i]; if (i > 0 && subPatternNames[i - 1] !== undefined) {matches[subPatternNames] = array[0][i]; } } return 1; }
RegExp.prototype.match_all = function() {function _find_parens_sub(ptr, count) {var count = count || 0; var start_count = count; var hwm_count = start_count; var i = 0; var dup_parens = false; if(ptr[0] == '(') {if(ptr[1] == '?' && ptr[2] == '|') {i += 3; dup_parens = true; } else if(ptr[1] != '?' && ptr[1] != '*') {count += 1; i++; } else if(ptr[i + 2] == '(') {i += 2; if(ptr[i + 1] != '(') {while(!!ptr[i] && ptr[i] != ')') i++; if(ptr[i] != 0) i++; } } else {i += 2; if(ptr[i] == 'P') i++; if((ptr[i] == '<' && ptr[i + 1] != '!' && ptr[i + 1] != '=') || ptr[i] == '\'') {count++; } } } for(; !!ptr[i]; i++) {if(ptr[i] == '\\') {if(!ptr[++i]) throw new Error('Weird backslash ?'); if(ptr[i] == 'Q') {for(;;) {while(!!ptr[++i] && ptr[i] != '\\') {}; if(!ptr[i]) throw new Error('No \\E ?'); if(ptr[++i] == 'E') break; } } continue; } if(ptr[i] == '[') {var negate_class = false; for(;;) {var c = ptr[++i]; if(c == '\\') {if(ptr[i] == 'E') i++; else if(!_strncmp(ptr[i + 1]), 'Q\\E', 3) {i += 3; } else {break; } } else if(!negate_class && c == '^') {negate_class = true; } else break; } if(ptr[i] == ']' && false) {i++; } while(ptr[++i] != ']') {if(!ptr[i]) {return count; } if(ptr[i] == '\\') {if(!ptr[++i]) throw new Error('Weird backslash ?'); if(ptr[i] == 'Q') {for(;;) {while(!!ptr[++i] && ptr[i] != '\\') {}; if(!ptr[i]) throw new Error('No \\E ?'); if(ptr[++i] == 'E') break; } } continue; } } continue; } if(ptr[i] == '(') {count = _find_parens_sub(ptr.slice(i), count); return count; } else if(ptr[i] == ')') {if(dup_parens && count < hwm_count) count = hwm_count; } else if(ptr[i] == '|' && dup_parens) {if(count > hwm_count) hwm_count = count; count = start_count; } } return count; } function _strncmp(str1, str2, lgth) {var s1 = (str1 + '') .substr(0, lgth); var s2 = (str2 + '') .substr(0, lgth); return((s1 == s2) ? 0 : ((s1 > s2) ? 1 : -1)); } return function(pattern, s, flag, offset) {var order = flag || 'PREG_PATTERN_ORDER'; var matches = []; var nbP = _find_parens_sub(pattern.source); if(typeof (offset) !== 'undefined' && offset > 0) {var ps = pattern.toString(); var delimiter = ps.charAt(0); var t = ps.split(delimiter); t.shift(); var flags = t.pop(); t[0] = '.{' + offset + '}' + t[0]; ps = t.join(delimiter); pattern = new RegExp(ps, flags); } if(order == 'PREG_PATTERN_ORDER' || order == 'PREG_OFFSET_CAPTURE') {for(var i = 0; i < 1 + nbP; i++) {matches[i] = []; } } s.replace(pattern, function () {var args = [].slice.call(arguments); var fullMatch = args.pop(); var offset = args.pop(); var substr = args[0]; if(order === 'PREG_SET_ORDER') {matches.push(args); } else if(order === 'PREG_PATTERN_ORDER') {var l = args.length; matches[0].push(substr); for(var i = 1; i < l; i++) {if(!matches[(i)]) matches[(i)] = []; matches[(i)].push(args[i]); } } else if(order === 'PREG_OFFSET_CAPTURE') {if(!matches[0]) matches[0] = []; matches[0].push([args[0], offset]); var l = args.length; for(var i = 1; i < l; i++) {if(!matches[i]) matches[i] = []; matches[i].push([args[i], fullMatch.indexOf(args[i])]); } } }); return matches; }; }
RegExp.prototype.MULTILINE = 4;
RegExp.prototype.quote = function() {return pattern.escape(); };
RegExp.prototype.quote = function(delimiter) {return String(this).replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\' + (delimiter || '') + '-]', 'g'), '\\$&'); }
RegExp.prototype.replace = function(replacement, subject, limit) {var pattern = this; if (typeof limit === 'undefined') limit = -1; if (subject.match(eval(pattern))) {if (limit == -1) {return subject.replace(eval(pattern + 'g'), replacement); } else {for (x = 0; x < limit; x++) {subject = subject.replace(eval(pattern), replacement); } return subject; } } else {return subject; } }
RegExp.prototype.replace_callback = function(callback, subject, limit) {var pattern = this; if (typeof pattern !== 'string') {return false;} if (typeof callback !== 'function') {return false;} if (typeof subject !== 'string') {return false;} if (typeof limit === 'undefined') {limit = -1;} if (typeof limit !== 'number') {return false;} pattern = eval(pattern); if (pattern.test(subject)) {var modified = ''; for (var i = 0; (i < limit || limit === -1); i++) {var match = subject.match(pattern); if (match === null) {break;} subject = subject.split(match[0], 2); modified += subject[0] + callback(match); subject = (subject[1] || ''); } subject = modified + subject; } return subject; }
RegExp.prototype.split = function(subject, limit, flags) {var pattern = this; limit = limit || 0; flags = flags || ''; var result, ret = [], index = 0, i = 0, noEmpty = false, delim = false, offset = false, OPTS = {}, optTemp = 0, regexpBody = /^\/(.*)\/\w*$/.exec(pattern.toString())[1], regexpFlags = /^\/.*\/(\w*)$/.exec(pattern.toString())[1]; pattern = pattern.global && typeof pattern !== 'string' ? pattern : new RegExp(regexpBody, regexpFlags + (regexpFlags.indexOf('g') !== -1 ? '' : 'g')); OPTS = {'PREG_SPLIT_NO_EMPTY': 1, 'PREG_SPLIT_DELIM_CAPTURE': 2, 'PREG_SPLIT_OFFSET_CAPTURE': 4 }; if (typeof flags !== 'number') {flags = [].concat(flags); for (i = 0; i < flags.length; i++) {if (OPTS[flags[i]]) {optTemp = optTemp | OPTS[flags[i]]; } } flags = optTemp; } noEmpty = flags & OPTS.PREG_SPLIT_NO_EMPTY; delim = flags & OPTS.PREG_SPLIT_DELIM_CAPTURE; offset = flags & OPTS.PREG_SPLIT_OFFSET_CAPTURE; var _filter = function(str, strindex) {if (noEmpty && !str.length) {return;} if (offset) {str = [str, strindex];} ret.push(str); }; if (!regexpBody) {result = subject.split(''); for (i = 0; i < result.length; i++) {_filter(result[i], i); } return ret; } while (result = pattern.exec(subject)) {if (limit === 1) {break;} _filter(subject.slice(index, result.index), index); index = result.index + result[0].length; if (delim) {var resarr = Array.prototype.slice.call(result); for (i = 1; i < resarr.length; i++) {if (result[i] !== undefined) {_filter(result[i], result.index + result[0].indexOf(result[i])); } } } limit--; } _filter(subject.slice(index, subject.length), index); return ret; }
RegExp.prototype.sql_regcase = function(str) {var str = this; var i = 0, upper = '', lower = '', pos = 0, retStr = ''; for (i = 0; i < str.length; i++) {if (((pos = upper.indexOf(str.charAt(i))) !== -1) || ((pos = lower.indexOf(str.charAt(i))) !== -1)) {retStr += '[' + upper.charAt(pos) + lower.charAt(pos) + ']'; } else {retStr += str.charAt(i); } } return retStr; }
